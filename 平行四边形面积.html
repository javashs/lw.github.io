<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>平行四边形面积</title>
<style>
  :root{
    --cell: 52px; /* 单格大小 */
    --cols: 16;   
  }
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  .wrap{
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    gap:24px;
    padding:24px;
    box-sizing:border-box;
    background:#f6f7fb;
  }
  .card{
    background:white;
    border-radius:12px;
    box-shadow:0 6px 22px rgba(20,20,40,0.08);
    padding:18px;
    width: max-content;
  }
  .svg-wrap{
    width: calc(var(--cell) * var(--cols));
    background: transparent;
    border-radius:8px;
    padding:10px;
  }
  svg{ display:block; width:100%; height:auto; background:transparent; user-select:none; touch-action:none;}
  .info{
    margin-top:12px;
    display:flex;
    gap:12px;
    align-items:center;
    justify-content:space-between;
  }
  .info .left{ font-size:14px;color:#111827; }
  .info .right{ font-size:13px;color:#374151; }
  .controls{
    margin-top:10px;
    display:flex;
    gap:12px;
    align-items:center;
  }
  .btn{
    background:#0ea5a4;color:white;border:0;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600;
  }
  .small{ font-size:13px;color:#374151; }
  .handle{ cursor:ew-resize; touch-action:none; }
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div style="display:flex;align-items:center;gap:12px;">
      <div class="small" style="margin-left:auto;font-size:20px;">每个格子： <strong id="cellSizeText">2</strong></div>
    </div>

    <div class="svg-wrap" id="svgWrap">
      <svg id="paper" xmlns="http://www.w3.org/2000/svg" aria-label="grid drawing">
        <g id="scene" transform="translate(36,36)"></g>
      </svg>
    </div>

    <div class="info">
      <div class="left" style="font-size:18px; color:transparent;">
  长 = <strong id="base">6</strong> 米，高 = <strong id="height">4</strong> 米
</div>
      <div class="right">
        <div style="font-size:18px;">面积 = <strong id="areaValue">24</strong> 平方米</div>
      </div>
    </div>

    <div class="controls">
      <input id="sRange" type="range" min="0" max="20" step="0.1" value="0" style="width:260px;">
      <button id="snapBtn" class="btn">格点对齐</button>
      <button id="resetBtn" class="btn" style="background:#2563eb">矩形重置</button>
      <button id="showAreaBtn" class="btn" style="background:#10b981">显示面积</button>
      <button id="hideAreaBtn" class="btn" style="background:#f59e0b">隐藏面积</button>
    </div>
  </div>
</div>

<script>
const areaDiv = document.getElementById('areaValue');

document.getElementById('showAreaBtn').addEventListener('click', ()=> areaDiv.style.display='inline');
document.getElementById('hideAreaBtn').addEventListener('click', ()=> areaDiv.style.display='none');

(function(){
  const base = 6, height = 4;
  const cell = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell')) || 36;
  document.getElementById('cellSizeText').textContent = '1平方米';
  const svg = document.getElementById('paper');
  const scene = document.getElementById('scene');
  const vbWidth = (base+22)*cell;
  const vbHeight = (height+6)*cell;
  svg.setAttribute('viewBox', `0 0 ${vbWidth} ${vbHeight}`);

  let s = 0; // 水平偏移
  let currentHeight = height; // 当前高度
  areaDiv.style.display = 'none';

  function sx(u){ return cell + u*cell + 0.5; }
  function sy(v){ return cell + v*cell + 0.5; }

  function drawGrid(){
    const old = document.getElementById('cellGrid'); if(old) old.remove();
    const g = document.createElementNS('http://www.w3.org/2000/svg','g'); g.setAttribute('id','cellGrid');
    const cols = Math.ceil(vbWidth/cell);
    const rows = Math.ceil(vbHeight/cell);
    for(let i=0;i<=cols;i++){
      const x=i*cell;
      const line=document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1',x); line.setAttribute('y1',0); line.setAttribute('x2',x); line.setAttribute('y2',rows*cell);
      line.setAttribute('stroke','black'); line.setAttribute('stroke-width','1');
      g.appendChild(line);
    }
    for(let j=0;j<=rows;j++){
      const y=j*cell;
      const line=document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1',0); line.setAttribute('y1',y); line.setAttribute('x2',cols*cell); line.setAttribute('y2',y);
      line.setAttribute('stroke','black'); line.setAttribute('stroke-width','1');
      g.appendChild(line);
    }
    scene.appendChild(g);
  }

  function drawLabels(){
    const old = document.getElementById('labels'); if(old) old.remove();
    const g = document.createElementNS('http://www.w3.org/2000/svg','g'); g.setAttribute('id','labels');
    for(let i=0;i<=base;i++){
      const t=document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x',sx(i)+6); t.setAttribute('y',sy(height)+18); t.setAttribute('font-size','26');
      t.setAttribute('fill','rgba(0,0,0,0.6)'); t.textContent=i; g.appendChild(t);
    }
    for(let j=0;j<=height;j++){
      const t=document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x',sx(0)-18); t.setAttribute('y',sy(height-j)+4); t.setAttribute('font-size','26');
      t.setAttribute('fill','rgba(0,0,0,0.6)'); t.textContent=j; g.appendChild(t);
    }
    scene.appendChild(g);
  }

  const poly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
  poly.setAttribute('fill','rgba(59,130,246,0.12)');
  poly.setAttribute('stroke','#2563eb');
  poly.setAttribute('stroke-width','2');
  poly.setAttribute('stroke-linejoin','round');
  scene.appendChild(poly);

  const handleA=document.createElementNS('http://www.w3.org/2000/svg','circle');
  const handleB=document.createElementNS('http://www.w3.org/2000/svg','circle');
  [handleA,handleB].forEach(h=>{
    h.setAttribute('r',8); h.setAttribute('fill','#fff'); h.setAttribute('stroke','#0ea5a4'); h.setAttribute('stroke-width',2);
    h.classList.add('handle'); scene.appendChild(h);
  });

  const bottomY = sy(height);
  function updateVisualization(){
    const sPx = s*cell;
    const topY = sy(height - currentHeight);
    const TL={x:sx(0)+sPx,y:topY};
    const TR={x:sx(base)+sPx,y:topY};
    const BR={x:sx(base),y:bottomY};
    const BL={x:sx(0),y:bottomY};

    poly.setAttribute('points',`${BL.x},${BL.y} ${BR.x},${BR.y} ${TR.x},${TR.y} ${TL.x},${TL.y}`);
    handleA.setAttribute('cx',TL.x); handleA.setAttribute('cy',TL.y);
    handleB.setAttribute('cx',TR.x); handleB.setAttribute('cy',TR.y);

    document.getElementById('height').textContent=Math.round(currentHeight*100)/100;
    document.getElementById('areaValue').textContent=Math.round(base*currentHeight*100)/100;
  }

  drawGrid(); drawLabels(); updateVisualization();

  const sRange=document.getElementById('sRange');
  sRange.addEventListener('input', e=>{ s=parseFloat(e.target.value); updateVisualization(); });

  let snap=false;
  document.getElementById('snapBtn').addEventListener('click',()=>{ 
    snap=!snap; 
    document.getElementById('snapBtn').textContent=snap?'已启用格点对齐':'格点对齐'; 
    if(snap){ s=Math.round(s); sRange.value=s; updateVisualization(); } 
  });

  // 上一次轨迹
  let lastClone = null;
  let activeHandle = null;

  poly.addEventListener('pointerdown',(e)=>{
    activeHandle=poly; 
    activeHandle.setPointerCapture && activeHandle.setPointerCapture(e.pointerId);
    activeHandle._startClientX=e.clientX; 
    activeHandle._startClientY=e.clientY;
    activeHandle._startS=s; 
    activeHandle._startHeight=currentHeight;

    // 克隆当前矩形作为上一次轨迹
    if(lastClone && scene.contains(lastClone)) scene.removeChild(lastClone);
    lastClone = poly.cloneNode();
    lastClone.setAttribute('fill','rgba(128,128,128,0.2)');
    lastClone.setAttribute('stroke','rgba(128,128,128,0.4)');
    lastClone.setAttribute('stroke-width','2');
    scene.insertBefore(lastClone, poly);
  });

  function moveDragPoly(e){
    if(activeHandle!==poly) return;
    const dx=e.clientX-activeHandle._startClientX;
    const dy=e.clientY-activeHandle._startClientY;
    const rect=svg.getBoundingClientRect();
    const vb=svg.viewBox.baseVal;
    let newS=activeHandle._startS + dx/rect.width*vb.width/cell;
    let newHeight=activeHandle._startHeight - dy/rect.height*vb.height/cell;
    if(newHeight<0.5) newHeight=0.5;
    if(newHeight>height) newHeight=height;
    if(newS<0) newS=0;
    if(newS>20) newS=20;
    s=newS; currentHeight=newHeight;
    updateVisualization();
  }

  function endDragPoly(e){
    if(activeHandle===poly){
      try{ activeHandle.releasePointerCapture && activeHandle.releasePointerCapture(e.pointerId);}catch(e){}
      activeHandle = null;
    }
  }

  document.getElementById('resetBtn').addEventListener('click', () => {
    s=0; currentHeight=height; sRange.value=0; updateVisualization();
    if(lastClone && scene.contains(lastClone)) scene.removeChild(lastClone);
    lastClone = null;
  });

  svg.addEventListener('pointermove',moveDragPoly);
  svg.addEventListener('pointerup',endDragPoly);
  svg.addEventListener('pointercancel',endDragPoly);

})();
</script>
</body>
</html>